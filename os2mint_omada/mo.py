# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from __future__ import annotations

from itertools import chain
from typing import NewType
from uuid import UUID

import structlog
from more_itertools import one
from more_itertools import only
from ramodels.mo import Employee
from ramodels.mo import Validity
from ramodels.mo._shared import UUIDBase
from ramodels.mo.details import Address
from ramodels.mo.details import Engagement
from ramodels.mo.details import ITUser

from os2mint_omada.autogenerated_graphql_client import GraphQLClient
from os2mint_omada.util import validity_union

logger = structlog.get_logger(__name__)

ITSystems = NewType("ITSystems", dict[str, UUID])


class MO:
    def __init__(self, graphql_client: GraphQLClient) -> None:
        self.graphql_client = graphql_client

    async def get_it_systems(self, user_keys: list[str]) -> ITSystems:
        """Get IT Systems configured in MO.

        Args:
            user_keys: IT systems to fetch.

        Returns: Mapping from IT system user key to UUID.
        """
        result = await self.graphql_client.get_it_systems(user_keys=user_keys)
        return ITSystems(
            {o.current.user_key: o.current.uuid for o in result.objects if o.current}
        )

    async def get_classes(self, facet_user_key: str) -> dict[str, UUID]:
        """Get classes for the given facet user key.

        Args:
            facet_user_key: Facet to retrieve classes for.

        Returns: Mapping from class user key to UUID.
        """
        result = await self.graphql_client.get_classes(user_keys=[facet_user_key])
        facet = one(result.objects).current
        assert facet is not None
        return {c.user_key: c.uuid for c in facet.classes}

    async def get_employee_uuid_from_user_key(self, user_key: str) -> UUID | None:
        """Find employee UUID by user key.

        Omada users are linked to MO employees through user keys on the employee's
        engagements.

        Args:
            user_key: User key to find employee for.

        Returns: Employee UUID if found, otherwise None.
        """
        result = await self.graphql_client.get_employee_uuid_from_user_key(
            user_keys=[user_key]
        )
        engagements = result.objects
        if not engagements:
            return None
        objects = chain.from_iterable(e.objects for e in engagements)
        employees = chain.from_iterable(o.person for o in objects)
        uuids = {e.uuid for e in employees}
        return one(uuids)  # it's an error if different UUIDs are returned

    async def get_employee_uuid_from_cpr(self, cpr: str) -> UUID | None:
        """Find employee UUID by CPR number.

        Args:
            cpr: CPR number to find employee for.

        Returns: Employee UUID if matching employee exists, otherwise None.
        """
        result = await self.graphql_client.get_employee_uuid_from_cpr(cpr_numbers=[cpr])
        employees = result.objects
        if not employees:
            return None
        uuids = {e.uuid for e in employees}
        return one(uuids)  # it's an error if different UUIDs are returned

    async def get_employee_states(self, uuid: UUID) -> set[Employee]:
        """Retrieve employee states.

        The retrieved fields correspond to the fields which are synchronised from
        Omada, i.e. exactly the fields we are interested in, to check up-to-dateness.

        Args:
            uuid: Employee UUID.

        Returns: Set of employee objects; one for each state.
        """
        result = await self.graphql_client.get_employee_states(uuids=[uuid])
        employee = only(result.objects)
        if employee is None:
            return set()
        return {Employee.parse_obj(o) for o in employee.objects}

    async def get_current_employee_state(self, uuid: UUID) -> Employee | None:
        """Retrieve current employee state.

        Args:
            uuid: Employee UUID.

        Returns: Employee objects.
        """
        result = await self.graphql_client.get_current_employee_state(uuids=[uuid])
        employee = only(result.objects)
        if employee is None:
            return None
        return Employee.parse_obj(employee.current)

    async def get_employee_addresses(
        self, uuid: UUID, address_types: list[UUID] | None = None
    ) -> set[Address]:
        """Retrieve addresses related to an employee.

        Args:
            uuid: Employee UUID.
            address_types: Only retrieve the given address types, to avoid terminating
             addresses irrelevant to Omada.

        Returns: Set of addresses related to the employee.
        """
        result = await self.graphql_client.get_employee_addresses(
            employee_uuids=[uuid],
            address_types=address_types,
        )
        employee = only(result.objects)
        if employee is None:
            return set()
        addresses = chain.from_iterable(o.addresses for o in employee.objects)
        return {
            Address.from_simplified_fields(
                uuid=address.uuid,
                value=address.value,
                address_type_uuid=address.address_type.uuid,
                person_uuid=one({p.uuid for p in (address.person or [])}),
                engagement_uuid=only({e.uuid for e in (address.engagement or [])}),
                visibility_uuid=visibility.uuid
                if (visibility := address.visibility) is not None
                else None,
                from_date=address.validity.from_.isoformat(),
                to_date=to.isoformat()
                if (to := address.validity.to) is not None
                else None,
            )
            for address in addresses
        }

    async def get_employee_engagements(self, uuid: UUID) -> set[Engagement]:
        """Retrieve engagements related to an employee.

        Args:
            uuid: Employee UUID.

        Returns: Set of engagements related to the employee.
        """

        result = await self.graphql_client.get_employee_engagements(
            employee_uuids=[uuid]
        )
        employee = only(result.objects)
        if employee is None:
            return set()
        engagements = chain.from_iterable(o.engagements for o in employee.objects)
        return {
            Engagement.from_simplified_fields(
                uuid=engagement.uuid,
                user_key=engagement.user_key,
                org_unit_uuid=one({o.uuid for o in engagement.org_unit}),
                person_uuid=one({p.uuid for p in engagement.person}),
                job_function_uuid=engagement.job_function.uuid,
                engagement_type_uuid=engagement.engagement_type.uuid,
                primary_uuid=primary.uuid
                if (primary := engagement.primary) is not None
                else None,
                from_date=engagement.validity.from_.isoformat(),
                to_date=to.isoformat()
                if (to := engagement.validity.to) is not None
                else None,
            )
            for engagement in engagements
        }

    async def get_employee_it_users(
        self, uuid: UUID, it_systems: list[UUID]
    ) -> set[ITUser]:
        """Retrieve IT users related to an employee.

        Args:
            uuid: Employee UUID.
            it_systems: Only retrieve IT users for the given IT systems, to avoid
             terminating IT users irrelevant to Omada.

        Returns: Set of IT users related to the employee.
        """
        result = await self.graphql_client.get_employee_it_users(employee_uuids=[uuid])
        employee = only(result.objects)
        if employee is None:
            return set()
        it_users = chain.from_iterable(o.itusers for o in employee.objects)
        converted_it_users = (
            ITUser.from_simplified_fields(
                uuid=it_user.uuid,
                user_key=it_user.user_key,
                itsystem_uuid=it_user.itsystem.uuid,
                person_uuid=one({p.uuid for p in (it_user.person or [])}),
                engagement_uuid=only({e.uuid for e in (it_user.engagement or [])}),
                from_date=it_user.validity.from_.isoformat(),
                to_date=to.isoformat()
                if (to := it_user.validity.to) is not None
                else None,
            )
            for it_user in it_users
        )
        # Ideally IT users would be filtered directly in GraphQL, but it is not
        # currently supported. TODO(#59335): is it possible now?
        return {u for u in converted_it_users if u.itsystem.uuid in it_systems}

    async def get_org_unit_with_it_system_user_key(self, user_key: str) -> UUID:
        """Find organisational unit with the given IT system user user_key.

        Args:
            user_key: IT system user_key to find org unit for.

        Returns: UUID of the org unit if found, otherwise raises KeyError.
        """
        result = await self.graphql_client.get_org_unit_with_it_system_user_key(
            user_keys=[user_key]
        )
        it_users = result.objects
        if not it_users:
            raise KeyError(f"No organisation unit with {user_key=} found")
        objects = chain.from_iterable(u.objects for u in it_users)
        uuids = {ou.uuid for o in objects for ou in o.org_unit or []}
        return one(uuids)  # it's an error if different UUIDs are returned

    async def get_org_unit_with_uuid(self, uuid: UUID) -> UUID:
        """Get organisational unit with the given UUID, validating that it exists.

        Args:
            uuid: UUID of the org unit to look up.

        Returns: UUID of the org unit if it exists, otherwise raises KeyError.
        """
        result = await self.graphql_client.get_org_unit_with_uuid(uuids=[uuid])
        try:
            org_unit = one(result.objects)
        except ValueError as e:
            raise KeyError(f"No organisation unit with {uuid=} found") from e
        return org_unit.uuid

    async def get_org_unit_with_user_key(self, user_key: str) -> UUID:
        """Get organisational unit with the given user key, validating that it exists.

        Args:
            user_key: User key of the org unit to look up.

        Returns: UUID of the org unit if it exists, otherwise raises KeyError.
        """
        result = await self.graphql_client.get_org_unit_with_user_key(
            user_keys=[user_key],
        )
        try:
            org_unit = one(result.objects)
        except ValueError as e:
            raise KeyError(f"No organisation unit with {user_key=} found") from e
        return org_unit.uuid

    async def get_org_unit_validity(self, uuid: UUID) -> Validity:
        """Get organisational unit's validity.

        Args:
            uuid: UUID of the org unit.

        Returns: The org unit's validity.
        """
        result = await self.graphql_client.get_org_unit_validity(
            uuids=[uuid],
        )
        org_unit = one(result.objects)
        objs = org_unit.objects
        # Consolidate validities from all past/present/future versions of the org unit
        validities = (
            Validity(
                from_date=obj.validity.from_date,
                to_date=obj.validity.to_date,
            )
            for obj in objs
        )
        return validity_union(*validities)

    async def delete_address(self, obj: UUIDBase) -> None:
        """Delete a MO address.

        Args:
            obj: Address to delete.
        """
        logger.info("Deleting address", address=obj)
        await self.graphql_client.delete_address(uuid=obj.uuid)

    async def delete_engagement(self, obj: UUIDBase) -> None:
        """Delete a MO engagement.

        Args:
            obj: engagement to delete.
        """
        logger.info("Deleting engagement", engagement=obj)
        await self.graphql_client.delete_engagement(uuid=obj.uuid)

    async def delete_it_user(self, obj: UUIDBase) -> None:
        """Delete a MO it_user.

        Args:
            obj: it_user to delete.
        """
        logger.info("Deleting it_user", it_user=obj)
        await self.graphql_client.delete_it_user(uuid=obj.uuid)
